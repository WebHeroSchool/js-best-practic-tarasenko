__JavaScript Style Guide__

# Содержание
1. [Строгое равенство.](#строгоеравенство)
2. [Скрипт в конце страницы.](#скрипт)
3. [Переменные снаружи от цикла For.](#переменныевцикле)
4. [Переменные в глобальной области видимости.](#глобальныепеременные)
5. [Комментарии в коде.](#комментарии)
6. [Строка в "SetInterval" или "SetTimeOut".](#строкавsetinterval)
7. [Создание объекта.](#созданиеобъекта)
8. [Создание массива.](#созданиемассива)
9. [Default в switch.](#defaultswitch)
10. [Функция eval().](#функцияeval)


## Строгое равенство. <a name="строгоеравенство"></a>
В JavaScript используются два вида операторов равенства: === | !== и == | != . Рекомендуется всегда использовать первый набор при сравнении.

Однако при работе с == и != у вас могут возникнуть ошибки, если значения имеют различный тип данных. В этих случаях они попробуют преобразовать тип значений, что часто приводит к ошибкам.

## Скрипт в конце страницы. <a name="скрипт"></a>
Главная цель – сделать загрузку страницы максимально быстрой для пользователя. При загрузке скрипта браузер не может продолжить выполнение кода, пока не загружен весь файл. Поэтому, если скрипт размещается не в конце файла, пользователь должен будет ждать дольше, чтобы заметить какой-либо прогресс.

Если у вас имеются файлы JS, единственная цель которых – добавление какой-то функциональной возможности (например, после нажатия кнопки), то вперед, разместите эти файлы внизу, сразу перед закрывающим тегом body.

``` js
		<p>And now you know my favorite kinds of corn. </p>
		<script type="text/javascript" src="path/to/file.js"></script>
		<script type="text/javascript" src="path/to/anotherFile.js"></script>
	</body>
</html>
```

## Переменные снаружи от цикла For. <a name="переменныевцикле"></a>
Объявляйте переменные снаружи от цикла For. 
При выполнении длинных циклов «for» не создавайте дополнительной нагрузки на движок. Например:
	
``` js
	for(let i = 0; i < someArray.length; i++) {
		let container = document.getElementById('container');
		container.innerHtml += 'my number: ' + i;
		console.log(i);
 	}
```
Необходимо определять длину массива при каждой итерации и как мы каждый раз обходим DOM для получения элемента с id "container" – очень неэффективно!

Более удачный вариант:

``` js
	let container = document.getElementById('container');
	for(var i = 0, len = someArray.length; i < len;  i++) {
		container.innerHtml += 'my number: ' + i;
		console.log(i);
	}
```

## Переменные в глобальной области видимости. <a name="глобальныепеременные"></a>
Уменьшите количество переменных в глобальной области видимости.
При сведении глобальных переменных к минимуму уменьшается и вероятность пересечения этих перемеенных
с переменными других приложений, виджетов, библиотек. Например:

``` js
	var name = 'Jeffrey';
	var lastName = 'Way';
	function doSomething() {...}
	console.log(name);
```
Более удачный вариант


``` js
	var DudeNameSpace = {
		name : 'Jeffrey',
		lastName : 'Way',
		doSomething : function() {...}
	}
 	console.log(DudeNameSpace.name);
```

## Комментарии в коде. <a name="комментарии"></a>
Комментируйте свой код. Код должен быть доступен и понятен любому программисту, который взялся за проект.

``` js
	// Cycle through array and echo out each name. 
	for(var i = 0, len = array.length; i < len; i++) {
		console.log(array[i]);
	}
```

## Строка в "SetInterval" или "SetTimeOut". <a name="строкавsetinterval"></a>
Не передавайте строку в "SetInterval" или "SetTimeOut". Рассмотрим следующий код:

``` js
	setInterval(
		"document.getElementById('container').innerHTML += 'My new number: ' + i", 3000
	);
```

Этот код не только неэффективен, но и в результате ее использования значительно понизится производительность вашего скрипта, возникнет огромный риск, связанный с нарушением секретности. Никогда не передавайте строку в "SetInterval" или "SetTimeOut". Вместо этого передавайте имя функции. Лучше так:

``` js
	setInterval(someFunction, 3000);
```

## Создание объекта. <a name="созданиеобъекта"></a>
Имеется множество способов создания объектов в JavaScript.
Вероятно, более традиционным способом является использование конструктора «new», например:

``` js
	let o = new Object();
	o.name = 'Jeffrey';
	o.lastName = 'Way';
	o.someFunction = function() {
		console.log(this.name);
	}
```

Вместо этого рекомендуется использовать более надежный способ создания объектов – при помощи литерала.

``` js
	let o = {
		name: 'Jeffrey',
		lastName = 'Way',
		someFunction : function() {
			console.log(this.name);
		}
	};
	
	let o = {};
```

За счет использования литералов объектов можно писать код, при помощи которого реализуется множество возможностей
и в то же время написание которого интуитивно понятно разработчику.
При этом нет необходимости в вызове конструктора напрямую или соблюдении верной последовательности передаваемых в функцию аргументов и т.д.

## Создание массива. <a name="созданиемассива"></a>
Для создания массива используйте квадратные скобки. Не создавайте массивы через конструктор new Array.

``` js
	var items = [];
```
```

## Условные символы и пробелы. <a name="условныесимволы"></a>
Отделяйте пробелами условные символы.

``` js
	return a < b ? a : b;
```

## Default в switch. <a name="defaultswitch"></a>
Всегда прописывайте в конце switch раздел default, даже если кажется, что в этом нет необходимости.

``` js
	switch (new Date().getDay()) {
  		case 0:
    			day = "Sunday";
    			break;
  		case 1:
			day = "Monday";
    			break;
  		case 2:
    			day = "Tuesday";
    			break;
  		case 3:
    			day = "Wednesday";
   		 	break;
  		default:
    			day = "Unknown";
	}
```

## Функция eval(). <a name="функцияeval"></a>

Функция "eval" предоставляет нам доступ к компилятору JavaScript. Собственно, с ее помощью мы можем выполнить код, переданный ей в виде строки.

В результате ее использования не только значительно понизится производительность вашего скрипта, но и могут читаться и меняться  локальные переменные. Избегайте ее использования!
